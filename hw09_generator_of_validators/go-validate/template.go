package main

import (
	"bytes"
	"text/template"
)

const code string = `// Code generated by cool go-validate tool; DO NOT EDIT.
package {{.File.PackageName}}

{{if .Imports}}
import (
	{{range .Imports}}
	"{{.}}"{{end}}
)
{{end}}

{{range $structIdx, $struct := .File.Structs}}
// {{$struct.Name}} validator
func ({{$struct.NameLetter}} {{$struct.Name}}) Validate() ([]ValidationError, error) {
	var errs []ValidationError

	{{range $fieldIdx, $field := .Fields}}
		{{range $nameIdx, $name := $field.Names}}

			{{if eq $field.Type.Type "array"}}
	for i := range {{$struct.NameLetter}}.{{$name}} {
			{{end}}

{{/*
If validating field has type is "string"
*/}}
			{{if eq $field.Type.Name "string"}}
				{{range $validatorIdx, $validator := $field.Validators}}

{{/*
Validator type is ValidateTypeLen
*/}}
					{{if eq $validator.Type "len"}}
	if len({{$struct.NameLetter}}.{{$name}}{{if eq $field.Type.Type "array"}}[i]{{end}}) != {{$validator.Value}} {
		errs = append(errs, ValidationError{
			Field: "{{$name}}",
						{{if eq $field.Type.Type "array"}}
			Err: fmt.Sprintf("field \"{{$name}}\" must be length is {{$validator.Value}} in index %d", i),
						{{else}}
			Err: "field \"{{$name}}\" must be length is {{$validator.Value}}",
						{{end}}
		})
	}
					{{end}}

{{/*
Validator type is ValidateTyperRgexp
*/}}
					{{if eq $validator.Type "regexp"}}
	{
		matched, err := regexp.MatchString("{{$validator.Value}}", {{$struct.NameLetter}}.{{$name}}{{if eq $field.Type.Type "array"}}[i]{{end}})
		if err != nil {
			return errs, err
		}
		if matched == false {
			errs = append(errs, ValidationError{
				Field: "{{$name}}",
						{{if eq $field.Type.Type "array"}}
				Err: fmt.Sprintf("field \"{{$name}}\" must be in regexp \"{{$validator.Value}}\" in index %d", i),
						{{else}}
				Err: "field \"{{$name}}\" must be in regexp \"{{$validator.Value}}\"",
						{{end}}
			})
		}
	}
					{{end}}

{{/*
Validator type is ValidateTypeIn
*/}}
					{{if eq $validator.Type "in"}}
	if !({{range $valueIdx, $value := $validator.Value}}{{if eq $valueIdx 0}}{{else}} ||{{end}} {{$struct.NameLetter}}.{{$name}}{{if eq $field.Type.Type "array"}}[i]{{end}} == "{{$value}}"{{end}}) {
		errs = append(errs, ValidationError{
			Field: "{{$name}}",
						{{if eq $field.Type.Type "array"}}
			Err: fmt.Sprintf("field \"{{$name}}\" must be in range {{$validator.Value}} in index %d", i),
						{{else}}
			Err: "field \"{{$name}}\" must be in range {{$validator.Value}}",
						{{end}}
		})
	}
					{{end}}

				{{end}}
			{{end}}

{{/*
If validating field has type is "int"
*/}}
			{{if eq $field.Type.Name "int"}}
				{{range $validatorIdx, $validator := $field.Validators}}

{{/*
Validator type is ValidateTypeMin
*/}}
					{{if eq $validator.Type "min"}}
	if {{$struct.NameLetter}}.{{$name}}{{if eq $field.Type.Type "array"}}[i]{{end}} < {{$validator.Value}} {
		errs = append(errs, ValidationError{
			Field: "{{$name}}",
						{{if eq $field.Type.Type "array"}}
			Err: fmt.Sprintf("field \"{{$name}}\" must be min is {{$validator.Value}} in index %d", i),
						{{else}}
			Err: "field \"{{$name}}\" must be min is {{$validator.Value}}",
						{{end}}
		})
	}
					{{end}}

{{/*
Validator type is ValidateTypeMax
*/}}
					{{if eq $validator.Type "max"}}
	if {{$struct.NameLetter}}.{{$name}}{{if eq $field.Type.Type "array"}}[i]{{end}} > {{$validator.Value}} {
		errs = append(errs, ValidationError{
			Field: "{{$name}}",
						{{if eq $field.Type.Type "array"}}
			Err: fmt.Sprintf("field \"{{$name}}\" must be max is {{$validator.Value}} in index %d", i),
						{{else}}
			Err: "field \"{{$name}}\" must be max is {{$validator.Value}}",
						{{end}}
		})
	}
					{{end}}


{{/*
Validator type is ValidateTypeIn
*/}}
					{{if eq $validator.Type "in"}}
	if !({{range $valueIdx, $value := $validator.Value}}{{if eq $valueIdx 0}}{{else}} ||{{end}} {{$struct.NameLetter}}.{{$name}}{{if eq $field.Type.Type "array"}}[i]{{end}} == {{$value}}{{end}}) {
		errs = append(errs, ValidationError{
			Field: "{{$name}}",
						{{if eq $field.Type.Type "array"}}
			Err: fmt.Sprintf("field \"{{$name}}\" must be in range {{$validator.Value}} in index %d", i),
						{{else}}
			Err: "field \"{{$name}}\" must be in range {{$validator.Value}}",
						{{end}}
		})
	}
					{{end}}

				{{end}}
			{{end}}

			{{if eq $field.Type.Type "array"}}
	}
			{{end}}

		{{end}}
	{{end}}

	return errs, nil
}
{{end}}

// This struct cointains validation error description
type ValidationError struct {
	Field string
	Err string
}
`

func PrepareTemplate(file File) (bytes.Buffer, error) {
	// Create a new template and parse the code into it.
	t := template.Must(template.New("code").Parse(code))

	templData := struct {
		Imports []string
		File    File
	}{
		Imports: prepareImports(file),
		File:    file,
	}

	var tpl bytes.Buffer
	if err := t.Execute(&tpl, templData); err != nil {
		return tpl, err
	}

	return tpl, nil
}

// Making list of importable packages.
func prepareImports(file File) []string {
	imports := map[string]struct{}{}
	for _, st := range file.Structs {
		for _, fl := range st.Fields {
			// If field type has is array, then imports a "fmt" package
			if fl.Type.Type == "array" {
				if _, ok := imports["fmt"]; !ok {
					imports["fmt"] = struct{}{}
				}
			}

			for _, vl := range fl.Validators {
				// If validator type has is ValidateTyperRgexp,
				// then imports a "regexp" package
				if vl.Type == "regexp" {
					if _, ok := imports["regexp"]; !ok {
						imports["regexp"] = struct{}{}
					}
				}
			}
		}
	}

	importsList := []string{}
	for p := range imports {
		importsList = append(importsList, p)
	}

	return importsList
}
